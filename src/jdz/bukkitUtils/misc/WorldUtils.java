
package jdz.bukkitUtils.misc;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;

import jdz.bukkitUtils.JonosBukkitUtils;
import jdz.bukkitUtils.fileIO.FileLogger;

/**
 * Methods to do with worlds and locations. Also methods for relating blocks /
 * entities in the world
 * based on their locations.
 *
 * @author Jaiden Baker
 */
public final class WorldUtils {

	/**
	 * Converts a location to the format "{worldName},{x},{y},{z},{pitch},{yaw}"
	 * 
	 * @param l
	 * @return
	 */
	public static String locationToString(Location l) {
		return l.getWorld().getName() + "," + l.getBlockX() + "," + l.getBlockY() + "," + l.getBlockZ() + ","
				+ l.getPitch() + "," + l.getYaw();
	}

	/**
	 * Converts a location to the format "{worldName},{x},{y},{z}" in a readable
	 * form
	 * 
	 * @param l
	 * @return
	 */
	public static String locationToLegibleString(Location l) {
		return l.getWorld().getName() + " (x:" + l.getBlockX() + ", y:" + l.getBlockY() + ", z:" + l.getBlockZ() + ")";
	}

	/**
	 * Creates a location from a string generated by WorldUtils.locationToString
	 * 
	 * @param s
	 * @return
	 */
	public static Location locationFromString(String s) {
		String[] args = s.split(",");
		try {
			World world = Bukkit.getWorld(args[0]);
			return new Location(world, Integer.parseInt(args[1]) + 0.5, Integer.parseInt(args[2]),
					Integer.parseInt(args[3]) + 0.5, Float.parseFloat(args[4]), Float.parseFloat(args[5]));
		}
		catch (Exception e) {
			new FileLogger(JonosBukkitUtils.getInstance()).createErrorLog(e,
					"Error parsing location with args: " + args);
			return null;
		}
	}

	public static String chunkToString(Chunk c) {
		return c.getWorld().getName() + "," + c.getX() + "," + c.getZ();
	}

	public static Chunk chunkFromString(String s) {
		String[] args = s.split(",");
		try {
			World world = Bukkit.getWorld(args[0]);
			return world.getChunkAt(Integer.parseInt(args[1]), Integer.parseInt(args[2]));
		}
		catch (Exception e) {
			new FileLogger(JonosBukkitUtils.getInstance()).createErrorLog(e,
					"Error parsing location with args: " + args);
			return null;
		}
	}

	/**
	 * Fetches the nearest solid block under the given location
	 * 
	 * @param l
	 * @return
	 */
	public static Block getNearestBlockUnder(Location l) {
		return l.getWorld().getBlockAt(getNearestLocationUnder(l));
	}

	@Deprecated
	public static Location getNearestLocationUnder(Location l) {
		Location location = new Location(l.getWorld(), l.getBlockX() + 0.5, l.getBlockY(), l.getBlockZ() + 0.5);
		while (!location.getBlock().getType().isSolid()) {
			location = location.add(0, -1, 0);
			if (location.getY() < 0) {
				return null;
			}
		}
		return location;
	}

	/**
	 * Fetches the nearest block, above or below the current block from bedrock to
	 * sky limit,
	 * whose material and data match the desired type
	 * 
	 * @param block
	 * @param blockType
	 * @param blockData
	 * @return the block, or null if not found
	 */
	public static Block getBlockAboveOrBelow(Block block, Material blockType, byte blockData) {
		return getBlockAboveOrBelow(block, blockType, blockData, 1);
	}

	@SuppressWarnings("deprecation")
	private static Block getBlockAboveOrBelow(Block block, Material blockType, byte blockData, int distance) {
		boolean maxHeightReached = block.getLocation().getBlockY() + distance > block.getWorld().getMaxHeight() - 1;
		boolean minHeightReached = block.getLocation().getBlockY() - distance < 1;

		if (maxHeightReached && minHeightReached)
			return null;

		if (!maxHeightReached) {
			Block blockAbove = block.getWorld().getBlockAt(block.getLocation().add(0, distance, 0));
			if (blockAbove.getType() == blockType && blockAbove.getData() == blockData)
				return blockAbove;
		}

		if (!minHeightReached) {
			Block blockBelow = block.getWorld().getBlockAt(block.getLocation().subtract(0, distance, 0));
			if (blockBelow.getType() == blockType && blockBelow.getData() == blockData)
				return blockBelow;
		}

		return getBlockAboveOrBelow(block, blockType, blockData, distance + 1);
	}

	public static boolean isEmptyColumn(Location loc) {
		return isEmptyColumn(loc.getWorld(), loc.getBlockX(), loc.getBlockZ(), loc.getBlockY());
	}

	public static boolean isEmptyColumn(World world, int x, int z) {
		return isEmptyColumn(world, x, z, -1);
	}

	public static boolean isEmptyColumn(World world, int x, int z, int yException) {
		for (int y = 0; y < world.getMaxHeight(); y++)
			if (yException != y && world.getBlockAt(x, y, z).getType() != Material.AIR)
				return false;
		return true;
	}

	/**
	 * Get a set of players who are near a given location spherically
	 * 
	 * @param location
	 * @param range
	 * @return
	 */
	public static Set<Player> getNearbyPlayers(Location location, double range) {
		double rangeSquared = range * range;
		Set<Player> nearbyPlayers = new HashSet<Player>();
		World world = location.getWorld();
		for (Player player : Bukkit.getOnlinePlayers())
			if (player.getWorld().equals(world))
				if (player.getGameMode() != GameMode.SPECTATOR)
					if (player.getLocation().distanceSquared(location) < rangeSquared)
						nearbyPlayers.add(player);
		return nearbyPlayers;
	}

	/**
	 * Gets the nearest player to a location
	 * 
	 * @param location
	 * @param maxRange ignore players further than the range, -1 for unlimited range
	 * @return the player, or null if none found
	 */
	public static Player getNearestPlayer(Location location, double maxRange) {
		double rangeSquared = maxRange * maxRange;

		Player nearest = null;
		double nearestDistSquared = maxRange <= 0 ? Double.MAX_VALUE : rangeSquared;

		for (Player player : location.getWorld().getPlayers()) {
			double distSquared = player.getLocation().distanceSquared(location);
			if (distSquared < nearestDistSquared) {
				nearest = player;
				nearestDistSquared = distSquared;
			}
		}
		return nearest;
	}

	/**
	 * Get a set of players who are within a given cuboid region
	 * 
	 * @param location
	 * @param range
	 * @return
	 */
	public static Set<Player> getPlayersInCuboid(Location origin, double width, double height, double depth) {
		if (width < 0) {
			origin.setX(origin.getX() + width);
			width *= -1;
		}
		if (height < 0) {
			origin.setY(origin.getY() + height);
			height *= -1;
		}
		if (depth < 0) {
			origin.setZ(origin.getZ() + depth);
			depth *= -1;
		}

		Set<Player> nearbyPlayers = new HashSet<Player>();
		World world = origin.getWorld();
		for (Player player : world.getPlayers()) {
			Location ploc = player.getLocation();
			if (ploc.getX() > origin.getX() && ploc.getX() < origin.getBlockX() + width)
				if (ploc.getY() > origin.getY() && ploc.getY() < origin.getY() + height)
					if (ploc.getZ() > origin.getZ() && ploc.getZ() < origin.getZ() + depth)
						nearbyPlayers.add(player);
		}
		return nearbyPlayers;
	}

	public static List<Location> getCircle(Location center, double radius, int amount) {
		World world = center.getWorld();
		double increment = (2 * Math.PI) / amount;
		List<Location> locations = new ArrayList<Location>();
		for (int i = 0; i < amount; i++) {
			double angle = i * increment;
			double x = center.getX() + (radius * Math.cos(angle));
			double z = center.getZ() + (radius * Math.sin(angle));
			locations.add(new Location(world, x, center.getY(), z));
		}
		return locations;
	}


	/**
	 * Comparator for locations, compares y, then x, then z
	 * @param l1
	 * @param l2
	 * @return
	 */
	public static int compareLocations(Location l1, Location l2) {
		if (l1.getY() > l2.getY())
			return -1;
		if (l1.getY() < l2.getY())
			return 1;

		if (l1.getX() > l2.getX())
			return -1;
		if (l1.getX() < l2.getX())
			return 1;

		if (l1.getZ() > l2.getZ())
			return -1;
		if (l1.getZ() < l2.getZ())
			return 1;

		return 0;
	}

	public static List<Chunk> getChunksDiamond(Chunk c, int radius) {
		if (radius <= 0)
			return Arrays.asList(c);

		List<Chunk> chunks = new ArrayList<Chunk>();
		World world = c.getWorld();
		int ix = c.getX();
		int iz = c.getZ();
		int xmin = ix - radius, xmax = ix + radius;
		int x = xmax, z = iz;
		for (; x > ix; x--) {
			chunks.add(world.getChunkAt(x, z));
			z++;
		}
		for (; x > xmin; x--) {
			chunks.add(world.getChunkAt(x, z));
			z--;
		}
		for (; x < ix; x++) {
			chunks.add(world.getChunkAt(x, z));
			z--;
		}
		for (; x < xmax; x++) {
			chunks.add(world.getChunkAt(x, z));
			z++;
		}
		return chunks;
	}

	public static List<Chunk> getChunksSquare(Chunk c, int radius) {
		if (radius <= 0)
			return Arrays.asList(c);

		List<Chunk> chunks = new ArrayList<Chunk>();
		World world = c.getWorld();
		int ix = c.getX();
		int iz = c.getZ();
		int xmin = ix - radius, xmax = ix + radius;
		int zmin = iz - radius, zmax = iz + radius;
		for (int x = xmin; x < xmax; x++) {
			chunks.add(world.getChunkAt(x, zmin));
			chunks.add(world.getChunkAt(x, zmax));
		}
		for (int z = zmin + 1; z < zmax - 1; z++) {
			chunks.add(world.getChunkAt(xmin, z));
			chunks.add(world.getChunkAt(xmax, z));
		}
		return chunks;
	}
}
